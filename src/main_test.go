package main

import (
	"bytes"
	"encoding/binary"
	"os"
	"path/filepath"
	"testing"

	"gopkg.in/yaml.v3"
)

// --- Test 1: Configuration Parsing ---

func TestManifestParsing(t *testing.T) {
	yamlContent := `
packages:
  - bat
  - ripgrep:
      config: .config/ripgrep
      channel: stable
guis:
  - obsidian
  - spotify:
      id: com.spotify.Client
env:
  EDITOR: nvim
`
	var m Manifest
	err := yaml.Unmarshal([]byte(yamlContent), &m)
	if err != nil {
		t.Fatalf("Failed to parse YAML: %v", err)
	}

	// Check simple package
	if m.Packages[0] != "bat" {
		t.Errorf("Expected 'bat', got %v", m.Packages[0])
	}

	// Check complex package
	rgMap, ok := m.Packages[1].(map[string]interface{})
	if !ok {
		t.Fatalf("Expected map for ripgrep")
	}
	// We need to marshal/unmarshal the inner map to Struct to test fully,
	// exactly like main.go does.
	rawCfg := rgMap["ripgrep"]
	b, _ := yaml.Marshal(rawCfg)
	var cfg PkgConfig
	yaml.Unmarshal(b, &cfg)

	if cfg.Channel != "stable" {
		t.Errorf("Expected channel 'stable', got '%s'", cfg.Channel)
	}

	// Check Env
	if m.Env["EDITOR"] != "nvim" {
		t.Errorf("Expected EDITOR=nvim")
	}
}

// --- Test 2: NAR Binary Parser Logic ---

// Helper to write Nix-style padded strings into a buffer
func writeNarString(buf *bytes.Buffer, s string) {
	// Write Length (8 bytes, little endian)
	binary.Write(buf, binary.LittleEndian, uint64(len(s)))
	// Write Data
	buf.WriteString(s)
	// Write Padding
	padding := (8 - (len(s) % 8)) % 8
	for i := 0; i < padding; i++ {
		buf.WriteByte(0)
	}
}

func TestReadString(t *testing.T) {
	var buf bytes.Buffer

	// Case A: Aligned string (8 chars) - No padding needed
	writeNarString(&buf, "12345678")
	
	// Case B: Unaligned string (3 chars) - Needs 5 bytes padding
	writeNarString(&buf, "abc")

	// Test Case A
	s, err := readString(&buf)
	if err != nil {
		t.Fatalf("Read error: %v", err)
	}
	if s != "12345678" {
		t.Errorf("Expected '12345678', got '%s'", s)
	}

	// Test Case B
	s, err = readString(&buf)
	if err != nil {
		t.Fatalf("Read error: %v", err)
	}
	if s != "abc" {
		t.Errorf("Expected 'abc', got '%s'", s)
	}
}

// --- Test 3: Garbage Collector (Stale Wrappers) ---

func TestCleanupStaleWrappers(t *testing.T) {
	// 1. Setup Temp Dir
	tmpDir, err := os.MkdirTemp("", "husk_test_bin")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	// Override the global BinDir for this test
	originalBinDir := BinDir
	BinDir = tmpDir
	defer func() { BinDir = originalBinDir }()

	// 2. Create Scenarios

	// A: Valid Wrapper (Should be kept)
	// Points to /nix/store/111-valid
	validScript := `#!/bin/sh
# Generated by husk
export LD_LIBRARY_PATH=/nix/store/111-valid/lib
exec "foo" "$@"`
	os.WriteFile(filepath.Join(tmpDir, "valid-tool"), []byte(validScript), 0755)

	// B: Stale Wrapper (Should be deleted)
	// Points to /nix/store/999-stale (which is NOT in our valid list)
	staleScript := `#!/bin/sh
# Generated by husk
export LD_LIBRARY_PATH=/nix/store/999-stale/lib
exec "old" "$@"`
	os.WriteFile(filepath.Join(tmpDir, "stale-tool"), []byte(staleScript), 0755)

	// C: User Script (Should be ignored/kept)
	// No "Generated by husk" header
	userScript := `#!/bin/sh
echo "I made this manually"`
	os.WriteFile(filepath.Join(tmpDir, "my-script"), []byte(userScript), 0755)

	// 3. Run Cleanup
	// We claim only "111-valid" is currently installed
	validPaths := []string{"/nix/store/111-valid"}
	cleanupStaleWrappers(validPaths)

	// 4. Assertions
	if _, err := os.Stat(filepath.Join(tmpDir, "valid-tool")); os.IsNotExist(err) {
		t.Error("Valid tool was incorrectly deleted")
	}

	if _, err := os.Stat(filepath.Join(tmpDir, "my-script")); os.IsNotExist(err) {
		t.Error("User script was incorrectly deleted")
	}

	if _, err := os.Stat(filepath.Join(tmpDir, "stale-tool")); err == nil {
		t.Error("Stale tool was NOT deleted")
	}
}